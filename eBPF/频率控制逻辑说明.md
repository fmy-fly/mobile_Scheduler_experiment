# 频率控制逻辑说明

## 整体架构

频率控制系统分为两个层次：
1. **事件检测层**：通过eBPF实时检测app启动事件
2. **频率控制层**：根据检测到的事件和配置，动态设置CPU/GPU频率

---

## 一、触发机制（何时启动频率控制）

### 1. 第一重触发：`activityStart` 事件（最快响应）

**触发时机**：检测到 `activityStart` 日志时（通常在app启动后20ms内）

**处理逻辑**：
```python
if "activityStart" in content:
    # 1. 立即设置boost频率（快速响应）
    set_cpu_mode("boost")
    
    # 2. 尝试从日志中提取包名
    # 格式: activityStart: cmp=com.tencent.mm/.ui.LauncherUI
    if "cmp=" in content:
        package_name = 提取包名
        if package_name in 配置列表:
            # 创建频率控制器并启动
            freq_controller = FrequencyController(package_name)
            freq_controller.start()
```

**优势**：
- ✅ 响应速度最快（20ms内）
- ✅ 在app真正开始初始化前就设置好频率
- ✅ 覆盖Dex加载、资源解压等重负载阶段

### 2. 第二重触发：`bindApplication` 事件（确认身份）

**触发时机**：app进程写入 `bindApplication` 日志时

**处理逻辑**：
```python
if "bindApplication" in content:
    # 1. 获取进程完整包名
    package_name = get_package_name(pid)
    
    # 2. 如果进程名是临时名（zygote64等），异步等待
    if pid_name in ["<pre-initialized>", "zygote64", "zygote"]:
        handle_cold_start_async(pid, pid_name)
        # 等待200ms后读取真实包名，然后启动频率控制
    else:
        # 直接启动频率控制
        freq_controller = FrequencyController(package_name)
        freq_controller.start()
```

**作用**：
- ✅ 确认应用身份（获取完整包名）
- ✅ 作为 `activityStart` 的补充，确保频率控制启动

---

## 二、频率控制器（FrequencyController）

### 初始化

```python
def __init__(self, app_package_name):
    # 1. 根据包名查找app名称（如 "com.tencent.mm" -> "微信"）
    # 2. 从 APP_FREQ_CONFIGS 中查找对应的频率配置
    # 3. 如果找到配置，准备启动时间段频率控制
```

### 启动流程（start方法）

```python
def start(self):
    # 1. 检查是否有时间段频率配置
    if not freq_config or not time_based:
        return
    
    # 2. 立即设置第一个时间段的频率（初始频率）
    first_period = periods[0]
    set_cpu_frequencies_local(first_period["cpu_freq"])
    set_gpu_frequency_local(first_period["gpu_freq"])
    
    # 3. 记录启动时间
    self.start_time = time.time()
    
    # 4. 启动后台监控线程
    monitor_thread.start()
```

### 时间段切换（_monitor_loop方法）

**监控循环**：每10ms检查一次

```python
def _monitor_loop(self):
    while self.is_running:
        # 1. 计算从启动到现在的经过时间
        elapsed = time.time() - self.start_time
        
        # 2. 检查是否进入新的时间段
        for idx, period in enumerate(periods):
            start_s = period.get("start", 0)
            end_s = period.get("end", float('inf'))
            
            if start_s <= elapsed < end_s and idx != last_period_index:
                # 3. 切换到新时间段的频率
                set_cpu_frequencies_local(period["cpu_freq"])
                set_gpu_frequency_local(period["gpu_freq"])
                last_period_index = idx
                break
        
        # 4. 如果超过最后一个时间段，停止监控
        if elapsed >= periods[-1].get("end", 10.0):
            self.is_running = False
            break
        
        time.sleep(0.01)  # 每10ms检查一次
```

**切换精度**：
- 检查间隔：10ms
- 切换延迟：<20ms（从检测到时间点到实际切换）

---

## 三、频率设置方法

### CPU频率设置

```python
def set_cpu_frequencies_local(cpu_freq_settings):
    # 对于每个policy（0, 4, 7）：
    for policy_id, freq_setting in cpu_freq_settings.items():
        # 1. 解析频率设置（单个值或范围）
        if isinstance(freq_setting, dict):
            min_freq = freq_setting.get('min')
            max_freq = freq_setting.get('max')
        else:
            min_freq = max_freq = int(freq_setting)
        
        # 2. 直接执行shell命令设置频率（本地执行，无网络延迟）
        execute_shell(f"echo {min_freq} > {policy_path}/scaling_min_freq", need_root=True)
        execute_shell(f"echo {max_freq} > {policy_path}/scaling_max_freq", need_root=True)
```

**执行方式**：
- 使用 `subprocess.run()` 在设备本地执行
- 通过 `su -c` 获取root权限
- 不使用adb，避免网络延迟

### GPU频率设置

```python
def set_gpu_frequency_local(gpu_freq_setting):
    # 类似CPU频率设置，写入GPU的sysfs文件
    execute_shell(f"echo {freq} > {GPU_PATH}/scaling_min_freq", need_root=True)
    execute_shell(f"echo {freq} > {GPU_PATH}/scaling_max_freq", need_root=True)
```

---

## 四、时间线示例（以小红书为例）

### 配置
```python
"小红书": {
    "periods": [
        {"start": 0.0, "end": 0.4, "cpu_freq": {...}, "gpu_freq": 850000},
        {"start": 0.4, "end": 10.0, "cpu_freq": {...}, "gpu_freq": 521000}
    ]
}
```

### 实际执行时间线

```
[T=0ms]    用户点击app图标
[T=20ms]   eBPF检测到 activityStart
           ↓
           [频率控制] 立即设置第一个时间段频率
           - CPU: policy0=1950MHz, policy4=2450MHz, policy7=3015MHz
           - GPU: 850MHz
           ↓
[T=50ms]   Zygote Fork新进程
[T=80ms]   检测到 bindApplication（确认身份）
           ↓
           [频率控制] 已启动，时间段数: 2
           （后台线程开始监控时间）
           ↓
[T=81ms]   应用开始加载Dex、解压资源（高负载）
           （此时CPU已处于高频，快速完成）
           ↓
[T=400ms]  后台线程检测到 elapsed = 0.4s
           ↓
           [频率切换] 切换到第二个时间段
           - CPU: policy0=1696MHz, policy4=2130MHz, policy7=2687MHz
           - GPU: 521MHz
           ↓
[T=548ms]  应用启动完成（根据Perfetto trace）
```

---

## 五、关键特性

### 1. 双重触发机制
- **第一重**：`activityStart` - 极速响应（20ms内）
- **第二重**：`bindApplication` - 确认身份

### 2. 本地执行
- 所有频率设置命令在设备本地执行
- 不使用adb，避免WiFi延迟（300-700ms → <20ms）

### 3. 时间段自动切换
- 后台线程每10ms检查一次
- 自动在配置的时间点切换频率
- 支持多时间段配置

### 4. 配置驱动
- 从 `freq_config.py` 读取配置
- 支持每个app的个性化配置
- 支持时间段频率配置

---

## 六、与其他触发点的关系

### 音频播放
```python
if line == "sys_event:AUDIO_ACTIVE":
    set_cpu_mode("boost")  # 使用固定boost频率，不使用时间段配置
```

### 输入法弹出
```python
if "showSoftInput" in content:
    set_cpu_mode("boost")  # 使用固定boost频率
```

### 触摸事件
```python
if "dispatchInputEvent" in content:
    if time.time() - self.last_input_time > 0.5:
        set_cpu_mode("boost")  # 使用固定boost频率
```

**注意**：这些触发点使用 `set_cpu_mode("boost")`，设置的是固定频率，**不会**启动时间段频率控制。只有检测到 `activityStart` 或 `bindApplication` 时才会启动时间段频率控制。

---

## 七、优势总结

| 特性 | 旧方案（WiFi+adb） | 新方案（eBPF本地） |
|------|-------------------|-------------------|
| **响应延迟** | 300-700ms | <20ms |
| **频率设置时机** | 启动后300-700ms | 启动后20ms内 |
| **时间段切换精度** | ±50ms（检查间隔） | ±10ms（检查间隔） |
| **网络依赖** | 需要WiFi连接 | 完全本地，无需网络 |
| **可靠性** | 受网络影响 | 高 |

---

## 八、配置示例

### 小红书配置
```python
"小红书": {
    "cpu_freq_settings": {
        "time_based": True,
        "periods": [
            {
                "start": 0.0,      # 启动后0秒开始
                "end": 0.4,        # 到0.4秒结束
                "cpu_freq": {
                    "0": 1950000,  # 小核：1.95 GHz（最高）
                    "4": 2450000,  # 中核：2.45 GHz（高）
                    "7": 3015000   # 大核：3.015 GHz（很高）
                },
                "gpu_freq": 850000  # GPU: 850 MHz（高）
            },
            {
                "start": 0.4,      # 0.4秒后
                "end": 10.0,       # 到10秒结束
                "cpu_freq": {
                    "0": 1696000,  # 降低频率
                    "4": 2130000,
                    "7": 2687000
                },
                "gpu_freq": 521000  # 降低GPU频率
            }
        ]
    }
}
```

---

## 九、故障处理

### 如果频率设置失败
- 使用 `errors='replace'` 处理编码错误
- 使用 `try-except` 捕获异常，不会导致程序崩溃
- 打印警告信息，但继续运行

### 如果找不到配置
- 打印 `[频率控制] 未找到配置`
- 不会启动时间段频率控制
- 其他功能（如boost模式）仍然可用

### 如果时间段切换不准确
- 时间段切换基于Python的 `time.time()`
- 与Perfetto trace的时间基准可能不一致（正常现象）
- 但频率设置仍然有效


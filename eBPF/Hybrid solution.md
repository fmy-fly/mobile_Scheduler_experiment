# 混合方案

## 1. pal_stream_write 性能杀手
在旧方案（纯日志方案 B）中，90% 的性能开销源自 `pal_stream_write` 的高频触发：

* **IO 开销**：每秒 500 次写入，意味着内核需执行 500 次 printf 操作输出到管道。
* **Python 开销**：用户态脚本需执行 500 次 read、split 及字符串匹配操作。
* **上下文切换**：内核态与用户态之间需不断切换以搬运这些字符串数据。

相比之下，新方案中的内核计数逻辑（@wake_count++）仅涉及几条 CPU 指令，开销几乎为零。

## 2. 性能提升对比分析
假设音频播放时 `pal_stream_write` 每秒触发 500 次，新旧方案开销对比如下：

| 指标 | 旧方案 (纯日志) | 新方案 (混合模式) | 提升幅度 |
| :--- | :--- | :--- | :--- |
| **内核 IO (Write)** | 500 次/秒 (写入 Pipe) | 2 次/秒 (写入 Pipe) | **降低 250 倍** |
| **Python 读取 (Read)** | 500 次/秒 | 2 次/秒 | **降低 250 倍** |
| **字符串处理** | 解析 500 行长 JSON | 比较 2 行短字符串 | **CPU 占用几乎归零** |
| **BPF 内部开销** | 高 (提取字符串参数) | 极低 (寄存器计数) | **大幅降低** |
| **缓冲区需求** | 需要 -b 16384 (16MB) | 默认 2MB 绰绰有余 | **内存节省 8 倍** |